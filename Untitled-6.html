<html>
  <head> </head>
  <body>
    <script>
      // const Left = x => f => g => f(x);
      // const Right = x => f => g => g(x);
      // const either = e => f => g => e(f)(g);
      // const id = x => x;

      // const eShow = res => res(id)(g => "Result is: " + g);

      // const x_ = Math.random();
      // const safeDiv = num => divisor =>
      //   divisor === 0 ? Left("Cannot divide by 0") : Right(num / divisor);

      // console.log(
      //   eShow(safeDiv(1)(0)) === "Cannot divide by 0" &&
      //     eShow(safeDiv(x_)(1)) === "Result is: " + x_
      // );
      // const twice = x => x * 2;
      // console.log([1,2,3].map(twice).toString() === "2,4,6")

      // const divides = x => y => y % x === 0;
      // console.log([1,2,3,4,5,6].filter(divides(3)).toString() === "3,6")

      // const join = x => (accu, cur) => accu + x + cur;
      // console.log([1,2,3].reduce(join('-')))
      // console.log([1,2,3].reduce(join('-')) === '1-2-3')

      //const bonusFormula = x => x.revenue * 0.2;
      // const bonusFormula = employee => employee.revenue * 0.2

      //const bonusCalculation = x => e.bonus = eval(bonusFormula(x));

      //let bonusCalculation = (employee) => employee.bonus = eval(bonusFormula)

      //const bonusCalculation = Function(e.bonus = bonusFormula(e.revenue));

      // function bonusCalculation (employee) {
      //   let usrFunc = Function('employee', 'return ' + bonusFormula);
      //   employee.bonus = usrFunc(employee);
      // }

      // let bonusCalculation = (employee) => {
      //     let f = Function('employee', 'return ' + bonusFormula);
      //     employee.bonus = f(employee)
      // }

      // const e = {revenue: 10000, bonus: null};
      // bonusCalculation(e);
      // const factor_ = 0.2;
      // console.log(e.bonus === e.revenue * factor_);

      // true: 1, 3

      // function Empty() { }

      // // const Empty = ( () => {
      // //   function Empty() { }
      // //   return Empty;
      // // }) ();

      // const empty = new Empty;
      // // const also = new Empty;

      // Empty.prototype.answer = 42;

      // // document.writeln(
      // //   empty.answer === 42 && also.answer === 42
      // // );

      // document.writeln(empty.answer === 42);

      // const Person = name => {
      //   let age = 0;
      //   return {
      //     getAge: () => age,
      //     setAge: newAge => age = newAge,
      //     getName: () => name,
      //     setName: newName => name = newName
      //   }
      // };

      // const me = Person("Myself");
      // //me.name = "***"
      // me.setName("Sherlock");
      // document.writeln(me.getName() === "Sherlock")

      // Person.prototype.getName = function() {  // functions are shared through the prototype // "=>" not allowed!
      //       return this.firstname + " " + this.lastname;
      // };

      // Array.prototype.eq = function(y) {
      //   if (this.length !== y.length){
      //     return false;
      //   }
      //   for (let i = 0; i < this.length; i++){
      //     if (this[i] !== y[i]){
      //       return false;
      //     }
      //   }
      //   return true;
      // };

      // function eq (x, y) {
      //   return x.length == y.length;
      // }

      // xs1_ = [1,2,3]
      // ys1_ = [1,2,3]
      // xs2_ = [1,2,3,4,5]
      // ys2_ = [1,2,2]
      

      // document.writeln(
      //   xs1_.eq(ys1_) &&
      //   !xs1_.eq(xs2_) &&
      //   !ys1_.eq(ys2_)

        // xs1_.eq(ys1_) &&
        //   !xs2_.eq(ys2_) &&
        //   xs3_.eq(ys3_) &&
        //   !xs3_.eq(ys4_) &&
        //   !xs4_.eq(ys3_)
      // );

      // 3 4 6 zweitletztes

      // class Person {
      //   isCool() {
      //     return this.name.length > 3;
      //     //return name === 'Dierk'
      //   }
      // }

      // const p = new Person();
      // p.name = "Dierk";
      // //document.writeln(p.name === "Dierk")
      // // const joe = {
      // //   name: "joe",
      // //   cool: p.isCool
      // // };
      // //p.isCool = () => true;
      // //Person.prototype.isCool = () => true;
      // document.writeln(p.isCool())
      // //document.writeln(joe.cool())

        // richtig 1 2 4 6 7 8 9

      // class Person {
      //   constructor(name) {
      //     this.name = name;
      //   }
      //   isCool() {
      //     return this.name.length > 3
      //   }
      // }
      // const p = new Person("Dierk");
      // document.writeln(p instanceof Person);

      // class Person { }
      // class Student extends Person { }
      // // // const p = { };
      // // // Object.setPrototypeOf(p, Person.prototype);
      // // // document.writeln(p instanceof Person);
      // // // class Student extends Person {}
      // const s = new Student();
      // //Object.setPrototypeOf(Student.prototype, Person.prototype)
      // document.writeln(s instanceof Person);

//       Q16a
// Assignment: Function composition
// Attempt number 1 of at most 3 attempts

// JavaScript is functional and functional languages should provide function composition.
// Let's assume we have functions like
//  const inc    = x => x + 1;
//  const double = x => x * 2;
// Provide a general function 'then' that can combine _any_ such functions such that
//  inc.then(double).then(double)
// can be used like
//  inc.then(double).then(double) (1) === 8  

// Note: you cannot assume what the functions are actually doing. 
// It must work for all functions!

// Remaining chars: 512
// Your solution will be tested against:

// add.then(mult).then(add) (1) === (1 + add_) * factor_ + add_

      // const inc    = x => x + 1;
      // const double = x => x * 2;

      // //try this first
      // Object.prototype.then = function(callback) {
      //   return () => callback(this)
      // }

      // Object.prototype.then = function(callback) {
      //   return (value) => callback(this(value))
      // }

      // document.writeln(inc.then(double).then(double) (1) === 8)


      // const Observable = value => {
      //   const listeners = [];
      //   return {
      //     onChange: callback => listeners.push(callback),
      //     getValue: () => value,
      //     setValue: val => {
      //       if (value === val) return;
      //       value = val;
      //       listeners.forEach(listener => listener(val));
      //     }
      //   }
      // }

      // true
      // const color = Observable('white');
      // let updateCount = 0;
      // color.onChange (_ => updateCount++);
      // color.setValue('black');
      // document.writeln( updateCount === 1 )

      // false
      // const color = Observable('white');
      // let observed = null;
      // color.onChange ( val => observed = val);
      // document.writeln( observed === color.getValue() )

      // false
      // const color = Observable('white');
      // let updateCount = 0;
      // color.onChange( _ => updateCount++);
      // color.setValue('white');
      // document.writeln(updateCount === 1)

      // true
      // const color = Observable('white');
      // document.writeln(color.getValue() === 'white')

      // true
      // const color = Observable('white');
      // color.setValue('black')
      // document.writeln(color.getValue() === 'black')

      // false
      // const color = Observable('white');
      // color.value = 'black'
      // document.writeln(color.getValue() === 'black')

      // true
      // const color = Observable('white');
      // let observed = color.getValue();
      // color.onChange(val => observed = val)
      // document.writeln(observed === color.getValue())

      // true
      // const color = Observable('white')
      // let updateCount = 0;
      // color.onChange( _ => updateCount++)
      // color.setValue('black')
      // color.setValue('white')
      // document.writeln(updateCount === 2)

      // false
      // const color = Observable('white')
      // let updateCount = 0;
      // const updateListener = val => updateCount++;
      // color.setValue('black')
      // document.writeln(updateCount === 1)

      // true
      // const color = Observable('white')
      // let observed = null;
      // color.onChange (val => observed = val)
      // color.setValue('black')
      // document.writeln(observed === color.getValue())

//       const Observable = value => {
//     const listeners = [];
//     return {
//         onChange: callback => {
//             listeners.push(callback);
//             callback(value, value);
//         },
//         getValue: ()       => value,
//         setValue: newValue => {
//             if (value === newValue) return;
//             const oldValue = value;
//             value = newValue;
//             listeners.forEach(callback => callback(value, oldValue));
//         }
//     }
// };

// let sum = 0;                                 
// const trackable = Observable(0);

// // Use 'trackable' such that it keeps track of the sum of all values 
// // that have been set to it in 'sum'.

// trackable.onChange(val => sum = sum + val);

// const x_ = 1;
// const y_ = 2;
// const z_ = 3;

// trackable.setValue(x_); // values x_, y_, z_ are given. Do not override.
// trackable.setValue(y_);
// trackable.setValue(z_);

// document.writeln(trackable.getValue() === z_ && sum === x_ + y_ + z_)

    // WEEK 10
    // 1 - false
    // const idPromise = x => new Promise( resolve => resolve(x));
    // const writer = x => {
    //   document.writeln(x);
    //   return idPromise(x);
    // };
    // const filterEven = n => n % 2 === 0 ? n : undefined;
    // idPromise(1)
    //   .then(writer)
    //   .then(filterEven)
    //   .then(writer);

    // 2 - true
    // const idPromise = x => new Promise( resolve => resolve(x));
    // const writer = x => {
    //   document.writeln(x);
    //   return idPromise(x);
    // };
    // const filterEven = n => { if (n % 2 === 0) return n; else throw Error("not even")};
    // idPromise(1)
    //   .then(writer)
    //   .then(filterEven)
    //   .then(writer)
    //   .catch(err => {});

    // 3 - false
    // const idPromise = x => new Promise( resolve => resolve(x));
    // document.writeln(idPromise(1))

    // 4 - true
    // const idPromise = x => new Promise( resolve => resolve(x));
    // const writer = x => {
    //   document.writeln(x);
    //   return idPromise(x);
    // };
    // const filterEven = n => n % 2 === 0 ? n : undefined;
    // idPromise(1)
    //   .then(writer)
    //   .then(filterEven)
    //   .then(writer);

    // 5 - true
    // const idPromise = x => new Promise( resolve => resolve(x));
    // idPromise(1)
    //   .then(it => document.writeln(it))

    // 6 - true
    // const idPromise = x => new Promise( resolve => resolve(x));
    // const writer = x => {
    //   document.writeln(x);
    //   return idPromise(x);
    // };
    // idPromise(1)
    //   .then(writer)
    //   .then(it => document.writeln(it))

    // 7 - false
    // const idPromise = x => new Promise( resolve => resolve(x));
    // idPromise(1)
    //   .then(it => document.writeln(it))
    //   .then(it => document.writeln(it))

    // 8 - true
    // const idPromise = x => new Promise( resolve => resolve(x));
    // idPromise(1)
    //   .then(it => {document.writeln(it); return idPromise(it)})
    //   .then(it => document.writeln(it))

    //9 - false
    // const idPromise = x => new Promise( resolve => resolve(x));
    // idPromise(1)
    //   .then(it => it)
    //   .then(it => document.writeln(it))

    //10 - true
    // const idPromise = x => new Promise( resolve => resolve(x));
    // const writer = x => {
    //   document.writeln(x);
    //   return idPromise(x);
    // };
    // const inc = n => n+1;
    // const filterEven = n => n % 2 === 0 ? n : undefined;
    // idPromise(1)
    //   .then(writer)
    //   .then(inc)
    //   .then(writer)
    //   .then(filterEven)
    //   .then(writer);

    // 11 - shows only 1 --> false
    // const idPromise = x => new Promise( resolve => resolve(x));
    // const writer = x => {
    //   document.writeln(x);
    //   return idPromise(x);
    // };
    // const filterEven = n => { if (n % 2 === 0) return n; else throw Error("not even")};
    // idPromise(1)
    //   .then(writer)
    //   .then(filterEven)
    //   .then(writer)
    //   .catch(err => {});

    // 12 - 1 undefined - false
    // const idPromise = x => new Promise( resolve => resolve(x));
    // const writer = x => {
    //   document.writeln(x);
    //   return idPromise(x);
    // };
    // const filterEven = n => n % 2 === 0 ? n : undefined;
    // idPromise(1)
    //   .then(writer)
    //   .then(filterEven)
    //   .then(writer);

    // 13 - true
    // const idPromise = x => new Promise( resolve => resolve(x));
    // idPromise(1)
    //   .then(it => {document.writeln(it); return it;})
    //   .then(it => document.writeln(it));

    // 14 - false
    // const idPromise = x => new Promise( resolve => resolve(x));
    // const writer = x => {
    //   document.writeln(x);
    //   return idPromise(x);
    // };
    // idPromise(1)
    //   .then(writer)
    //   .then(it => it + 1)
    //   .then(writer);

    // 15 - true

    // async await

    // 1 - false
    // const idPromise = x => new Promise( resolve => resolve(x));
    // const failPromise = err => new Promise( (resolve, reject) => reject(err));

    // const writer = x => {
    //   document.writeln(x);
    //   return idPromise(x);
    // }

    // const inc = n => idPromise(n + 1);
    // const filterEven = n => n % 2 === 0 ? idPromise(n) : failPromise("not even");

    // const foo = async i => {
    //   let x = await idPromise(i);
    //   while (x < 4) {
    //     x = await filterEven(x).catch( err => {});
    //     x = await writer(x);
    //     x = await inc(x);
    //   }
    // }
    // foo(1);

    // 2 - false
    // const idPromise = x => new Promise( resolve => resolve(x));
    // const failPromise = err => new Promise( (resolve, reject) => reject(err));

    // const writer = x => {
    //   document.writeln(x);
    //   return idPromise(x);
    // }

    // const inc = n => idPromise(n + 1);
    // const filterEven = n => n % 2 === 0 ? idPromise(n) : failPromise("not even");

    // const foo = async i => {
    //   let x = await idPromise(i);
    //   while (x < 4) {
    //     x = await filterEven(x);
    //     x = await writer(x);
    //     x = await inc(x);
    //   }
    // }
    // foo(1);

    // 3 - false
    // const idPromise = x => new Promise( resolve => resolve(x));
    // const failPromise = err => new Promise( (resolve, reject) => reject(err));
    // const writer = x => {
    //   document.writeln(x);
    //   return idPromise(x);
    // }

    // const foo = async i => {
    //   let x = await idPromise(i);
    //   x.then(writer)
    // }
    // foo(1);

    // 4 - true
    // const idPromise = x => new Promise( resolve => resolve(x));
    // const failPromise = err => new Promise( (resolve, reject) => reject(err));
    // const writer = x => {
    //   document.writeln(x);
    //   return idPromise(x);
    // }

    // const foo = async i => {
    //   let x = await idPromise(i);
    //   x = await writer(x);
    // }
    // foo(1);

    // 5 - true
    // const idPromise = x => new Promise( resolve => resolve(x));
    // const failPromise = err => new Promise( (resolve, reject) => reject(err));

    // const foo = async i => {
    //   let x = await idPromise(i);
    //   document.writeln(x);
    // }
    // foo(1);

    // 6 - 
    // 4 - true
    // const idPromise = x => new Promise( resolve => resolve(x));
    // const failPromise = err => new Promise( (resolve, reject) => reject(err));
    // const writer = x => {
    //   document.writeln(x);
    //   return idPromise(x);
    // }

    // const inc = n => idPromise(n + 1);

    // const foo = async i => {
    //   let x = await idPromise(i);
    //   while (x < 4) {
    //     x = await writer(x);
    //     x = await inc(x);
    //   }
    // }
    // foo(1);

    /*
    *Copy* the following code into the edit area and fill the ___ gaps.

const NullSafe = x => {
    const isNullSafe = y => y && y.then;
    const maywrap    = y => ___ ; // if y is not NullSafe yet, make it so
    return {
       then: fn => ___ // see(1)
    }
};

(1) if x is not null or undefined, call fn(x); either way, make sure the result is a NullSafe 

Fill the gaps such that NullSafe objects can be chained with their "then" function
just like Promises do, incl. auto-promotion of result values to NullSafe objects.

NullSafe(1).then(console.log);                   // will call the log
NullSafe(null).then(console.log);                // will not call the log
NullSafe(2).then( x => null).then(console.log);  // will not call the log
    */

// const NullSafe = x => {
//     const isNullSafe = y => y && y.then;
//     const maywrap    = y => isNullSafe(y) ? y : NullSafe(y);
//     return {
//        then: fn => {
//          if (x !== null && x !== undefined){
//            return maywrap(fn(x));
//          } else {
//            return maywrap(x);
//          }
//        }
//     }
// };

// let x_ = 1
// let y_ = 0

// console.log(NullSafe(x_)
//       .then( x => x*2)          // must auto-promote
//       .then( x => NullSafe(x))  // must not auto-promote
//       .then( x => y_ = x + 1)   // store value, check no double promotion
//       .then( x => null)         // jump over rest
//       .then( x => x.mustNotBeCalled) !== null && y_ === x_ * 2 + 1)

// 11.05.2020

// const Scheduler = () => {
//     let inProcess = false;
//     const tasks = [];
//     function process() {
//         if (inProcess) { return; }
//         if (tasks.length === 0) { return; } // guard clause
//         inProcess = true;
//         const task = tasks.pop();

//         new Promise( (resolve, reject) => {
//             task(resolve);
//         }). then ( () => {
//             inProcess = false;
//             process();
//         });
//     }
//     function add(task) {
//         tasks.unshift(task);
//         process();
//     }
//     return {
//         add: add,
//         addOk: task => add( ok => { task(); ok(); }) // convenience
//     }
// };

// 1 - false Logs 'x' and '0' or '3' or '1'. But only logs x

// let state = 3
// const scheduler = Scheduler();
// scheduler.add(ok => {
//   setTimeout(_ => {
//     state = state - 2;
//     ok();
//   }, 100)
// });
// scheduler.add(ok => {
//   state = state - 1;
//   ok();
// });

// console.log('x');

// 2 false - Shows '0,1,2' - only shows 0
// let state = [0];

// const scheduler = Scheduler();
// scheduler.add(ok => {
//   setTimeout(_ => {
//     state.push(1);
//     ok();
//   }, 100)
// });
// scheduler.add(ok => {
//   state.push(2);
//   ok();
// });
// document.writeln(state);

// 3 false - Shows 0 --> reality shows 0,1,2
// let state = [0];

// const scheduler = Scheduler();
// scheduler.add(ok => {
//   setTimeout(_ => {
//     state.push(1);
//     ok();
//   }, 100)
// });
// scheduler.add(ok => {
//   state.push(2);
//   ok();
// })
// scheduler.add(ok => {
//   document.writeln(state);
//   ok();
// });

// 4 - false - Shows '0,1' --> reality: 0,1,2
// let state = [0];

// const scheduler = Scheduler();
// scheduler.add(ok => {
//   setTimeout(_ => {
//     state.push(1);
//     ok();
//   }, 100)
// });
// scheduler.add(ok => {
//   state.push(2);
//   ok();
// });
// scheduler.add(ok => {
//   document.writeln(state);
//   ok();
// })

// 5 - false - Might show '0' but might just as well show nothing or '3' or '1'. - reality: shows 0
// let state = 3;

// const scheduler = Scheduler();
// scheduler.add(ok => {
//   setTimeout(_ => {
//     state = state - 2;
//     ok();
//   }, 100)
// })
// scheduler.add(ok => {
//   state = state - 1;
//   ok();
// })
// scheduler.add(ok => {
//   document.writeln(state);
//   ok();
// })

// 6 - true
// let state = 3;

// const scheduler = Scheduler();
// scheduler.add(ok => {
//   setTimeout(_ => {
//     state = state - 2;
//     ok();
//   }, 100)
// })
// scheduler.add(ok => {
//   state = state - 1;
//   ok();
// })
// scheduler.add(ok => {
//   document.writeln(state);
//   ok();
// })

// 7 - false
// let state = [0];

// const scheduler = Scheduler();
// scheduler.add(ok => {
//   setTimeout(_ => {
//     state.push(1);
//     ok();
//   }, 100)
// });
// scheduler.add(ok => {
//   state.push(2);
//   ok();
// });
// scheduler.add(ok => {
//   document.writeln(state);
//   ok();
// })

// 8 - false
// let state = [0]
// const scheduler = Scheduler()
// scheduler.add(ok => {
//   setTimeout(_ => {
//     state.push(1);
//     ok();
//   }, 100)
// });
// scheduler.add(ok => {
//   state.push(2)
//   ok();
// })
// document.writeln(state)

// 9 false

// 10 - true

// let state = 3
// const scheduler = Scheduler();
// scheduler.add(ok => {
//   setTimeout(_ => {
//     state = state - 2;
//     ok();
//   }, 100)
// });
// scheduler.add(ok => {
//   state = state - 1;
//   ok();
// });
// scheduler.add(ok => {
//   console.log(state)
//   ok()
// })

// console.log('x');

// 11 - true
// let state = [0];

// const scheduler = Scheduler();
// scheduler.add(ok => {
//   setTimeout(_ => {
//     state.push(1);
//     ok();
//   }, 100)
// });
// scheduler.add(ok => {
//   state.push(2);
//   ok();
// });
// scheduler.add(ok => {
//   document.writeln(state);
//   ok();
// })

// 12 - true
// let state = [0]
// const scheduler = Scheduler()
// scheduler.add(ok => {
//   setTimeout(_ => {
//     state.push(1);
//     ok();
//   }, 100)
// });
// scheduler.add(ok => {
//   state.push(2)
//   ok();
// })
// document.writeln(state)



// *******************************
// const DataFlowVariable = howto => {
//     let value = undefined;
//     return () => undefined === value
//                  ? value = howto()
//                  : value;
// };
// 1 - true
// const x = DataFlowVariable(() => y() * 2);
// let y = DataFlowVariable(() => 1);
// y = DataFlowVariable(() => 2);
// document.writeln(x());

// 2 - true
// const x = DataFlowVariable(() => y() * 2);
// let y = DataFlowVariable(() => 1);
// document.writeln(x());

// 3 - false
// const x = DataFlowVariable(() => y() * 2);
// let y = DataFlowVariable(() => 1);
// x();
// y = DataFlowVariable(() => 2);
// document.writeln(x());

// 4 - true
// const x = DataFlowVariable(() => y() * 2);
// let y = DataFlowVariable(() => 1);
// x();
// y = DataFlowVariable(() => 2);
// document.writeln(x());

// 5 - false
// const x = DataFlowVariable(() => y() * 2);
// let y = DataFlowVariable(() => 1);
// y = DataFlowVariable(() => 2);
// document.writeln(x());

  // 18.05.2020
  /*
  Implement a function named 'palindrome' that tells whether a given string
  is the same when read left-to-right and right-to-left, ignoring upper/lowercase differences
  and any characters outside 'a' to 'z'. For example
  palindrome('ABBA')  // true
  palindrome('Abba')  // true
  palindrome('A man, a plan, a canal: Panama!') // true

  You must use the following helper functions (they are provided):
  const str2chars = str  => [...str];            // convert a string to an array of chars
  const isAlpha   = char => char.match(/[a-z]/); // char is in the alphabet

  The question title contains implementation hints.
  */

  const str2chars = str  => [...str];            // convert a string to an array of chars
  const isAlpha   = char => char.match(/[a-z]/); // char is in the alphabet

  const palindrome = value => {
    let charArray = str2chars(value.toLowerCase());
    let alphaCharArray = charArray.filter(element => isAlpha(element))
    let i = 0;
    let j = alphaCharArray.length-1;
    console.log(alphaCharArray)
    while(i <= j){
      if (alphaCharArray[i] === alphaCharArray[j]){
        i++;
        j--;
      } else {
        return false;
      }
    }
    return true;
  }

  document.writeln(palindrome("Amore, Roma!"))
  document.writeln(palindrome("Madam, I'm Adam!") )
  document.writeln(palindrome("Never odd or even.") )
  document.writeln(!palindrome("Amore"))

    </script>
  </body>
</html>
